Below are **Question 5** and **Question 6** solved in full **CKS-exam style**, including:

âœ… Formula
âœ… Step-by-step solution
âœ… Exact YAML specs you would apply
âœ… Common exam mistakes to avoid

---

# ðŸ§© **QUESTION 5 â€” ServiceAccount: disable automount + mount projected token readOnly**

## ðŸŽ¯ **WHAT THE QUESTION WANTS**

1. Create a **ServiceAccount** in namespace `monitoring`
   â†’ **automountServiceAccountToken: false**

2. In a **Deployment**, mount this serviceAccountâ€™s token **as a projected volume**
   â†’ token must be **readOnly**
   â†’ must use `serviceAccountToken` type projection
   â†’ must specify `audience` + `path` + `expirationSeconds`

---

# âœ… **FORMULA (CKS CHEAT SHEET)**

### **ServiceAccount**

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: <sa-name>
  namespace: monitoring
automountServiceAccountToken: false
```

### **Deployment**

```yaml
spec:
  serviceAccountName: <sa-name>
  volumes:
  - name: token-vol
    projected:
      sources:
      - serviceAccountToken:
          path: token
          audience: api
          expirationSeconds: 3600
  containers:
  - name: app
    volumeMounts:
    - name: token-vol
      mountPath: /var/run/secrets/tokens
      readOnly: true
```

---

# ðŸ§± **STEP-BY-STEP SOLUTION (EXAM STYLE)**

## **Step 1 â€” Create the ServiceAccount**

```bash
kubectl create namespace monitoring
kubectl create serviceaccount monitor-sa -n monitoring
```

Now edit it:

```bash
kubectl edit sa monitor-sa -n monitoring
```

Add:

```yaml
automountServiceAccountToken: false
```

---

## **Step 2 â€” Modify Deployment to use projected token**

Open file or edit:

```bash
kubectl edit deployment mydeploy -n monitoring
```

Add under `.spec.template.spec`:

### volumes:

```yaml
volumes:
- name: token-vol
  projected:
    sources:
    - serviceAccountToken:
        path: token
        audience: api
        expirationSeconds: 3600
```

### container volumeMounts:

```yaml
containers:
- name: app
  image: myimg
  volumeMounts:
  - name: token-vol
    mountPath: /var/run/secrets/tokens
    readOnly: true
```

### serviceAccountName:

```yaml
serviceAccountName: monitor-sa
```

---

# **FULL EXPECTED ANSWER (Copy/Paste Ready)**

### **ServiceAccount**

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: monitor-sa
  namespace: monitoring
automountServiceAccountToken: false
```

### **Deployment**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: secure-app
  namespace: monitoring
spec:
  replicas: 1
  template:
    spec:
      serviceAccountName: monitor-sa

      volumes:
      - name: token-vol
        projected:
          sources:
          - serviceAccountToken:
              path: token
              audience: api
              expirationSeconds: 3600

      containers:
      - name: app
        image: nginx
        volumeMounts:
        - name: token-vol
          mountPath: /var/run/secrets/tokens
          readOnly: true
```

---

# âš ï¸ COMMON MISTAKES (CKS TRAPS)

âŒ Putting `automountServiceAccountToken` inside Deployment â€” wrong
âŒ Forgetting `projected` keyword
âŒ Using `secretRef` instead of `serviceAccountToken:`
âŒ Missing `readOnly: true` in volumeMount
âŒ Missing `serviceAccountName`

---

# ðŸ§© **QUESTION 6 â€” NetworkPolicies**

### **What the question wants:**

1. Create a NetworkPolicy that **DENIES all ingress** traffic in namespace `prod`.
2. Create another policy that **allows traffic from pods in namespace prod â†’ pods in namespace data**
   Using **pod labels** + **namespace selectors**.

---

# ðŸ§± PART 1 â€” Deny all ingress in namespace `prod`

Namespace must have **default deny** policy.

### **deny-all-ingress.yaml**

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
  namespace: prod
spec:
  podSelector: {}     # all pods
  policyTypes:
  - Ingress
  ingress: []          # deny everything
```

---

# ðŸ§± PART 2 â€” Allow pods from `prod` â†’ `data` namespace (ingress allow)

You must:

* Select pods in namespace `data` using **podSelector**
* Allow traffic only from pods in namespace `prod`
  â†’ using **namespaceSelector** with labels
  â†’ AND with podSelector

### **Pre-req:** Add labels to namespaces

```bash
kubectl label namespace prod name=prod --overwrite
kubectl label namespace data name=data --overwrite
```

---

### **allow-prod-to-data.yaml**

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-prod-to-data
  namespace: data
spec:
  podSelector:
    matchLabels:
      role: backend   # example: depends on question
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: prod
      podSelector:
        matchLabels:
          app: myapp   # example label from the question
```

> âš ï¸ In CKS, they will give you **labels of pods in prod** and **labels of pods in data**.
> Replace the labels with the ones from the question.

---

# ðŸ“Œ FINAL FORMULA SUMMARY FOR QUESTION 6

### Deny all ingress:

```yaml
podSelector: {}
ingress: []
policyTypes: [Ingress]
```

### Allow traffic from namespace prod:

```yaml
from:
- namespaceSelector: { label: prod }
  podSelector: { label: <prod-app-label> }
```

---

# ðŸš€ Want me to generate **all questions 1â€“6** again as a single combined mock exam?

I can produce a **CKS exam simulation** with all these tasks in a real kubeadm environment format.
